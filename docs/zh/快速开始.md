# 快速开始

[English](../quick_start.md) | 中文简体

## 流程解释
| 名称 | 项目类型 | 开发人员 | 解释 | 依赖 |
| -- | -- | -- | -- | -- |
| 游戏本体 | bin | 游戏开发者 | 游戏本体，wasm的host | bevy_modruntime |
| 游戏sdk | lib | 游戏开发者 | 为mod开发者提供的与游戏本体交互的sdk（需开源） | bevy_modsdk |
| 游戏mod | lib | mod开发者 | 游戏插件，由游戏本体进行加载 | bevy_modapi |

## 快速开发一个mod
### 游戏本体（bin）
游戏本体需要依赖一些依赖的Cargo.toml配置示例：
```toml
[package]
# ...package配置
[dependencies]
bevy = { version = "0.16", features = ["serialize"] }
serde = { version = "1.0", features = ["derive"] }
bincode = { version = "2.0", features = ["serde"] }
linkme = "0.3"
bevy_modruntime = "0.16"
# ...其他依赖
```
为游戏本体添加mod支持：
```rs
fn main() {
    App::new()
        .add_plugins(
            WasmModPlugin::default()
                .add_mod_path(
                    // 将此路径替换为真实mod路径
                    "path/to/your/mod.wasm",
                ),
        )
        // 在此添加其他其他插件
        // 注意: LogPlugin 是必要的
        .run();
}
```

### 游戏sdk（lib）
现在，我们先展示如何在mod中添加一个系统，这并不需要使用sdk，我们仅创建一个项目进行占位，之后我们将对其进行扩展。
Cargo.toml配置示例：
```toml
[package]
# ...package配置
[dependencies]
bevy_modsdk = "0.16"
serde = { version = "1.0", features = ["derive"] }
# ...其他依赖
```

### 游戏mod（lib）
现在，我们尝试编写一个mod，添加一个系统并输出`hello_world`

配置Cargo.toml
```toml
[package]
# ...package设置
[lib]
crate-type = ["cdylib"]  # Mods将会被编译为wasm
[dependencies]
bevy_modapi = "0.16"
game_sdk = { path = "path/to/gamesdk" }  # 替换为真实sdk路径
bincode = { version = "2.0", features = ["serde"] }
# ...其他依赖
```
然后在mod中添加一个系统
```rs
#[system(schedule = Update)] // 在PostUpdate阶段运行
pub fn example_update_system() {
    log_info!("Hello world from mod"); // 不要使用print!宏或者bevy的log宏
}

system_def!(example_update_system); // 添加system
```

### 编译&运行
#### 编译mod
mod目录下在终端中运行
```rs
cargo build --target wasm32-wasip1
```
这将编译mod为`wasm32-wasip1`平台可执行文件

*note: 由于rust对`wasm32-wasip1`的支持可能不稳定，最新的stable版本rustc可能无法编译为此目标平台。请先尝试使用最新stable版本的rustc，如果无法添加此目标平台，尝试安装1.86版本的rustc并为其添加此目标平台，并使用`cargo +1.86 build --target wasm32-wasip1`编译*

*note: 在正式发布时建议编译为release版本*

#### 编译游戏本体
确保在mod插件加载设置中，mod文件位置是正确的。

在游戏本体目录下的终端中运行
```rs
cargo run
```

*note: 可以使用动态链接*

#### 预期效果
运行游戏本体后，终端中将会输出日志`Hello world from mod`。

如果在游戏本体中启用了`MinimalPlugins`或`DefaultPlugins`，那么这行日志将会一直输出，因为System是在Update阶段运行的

## 更多关于`system`宏和`system_def`宏的信息
在以上示例中，我们使用了`system`过程宏来在mod中创建系统，`system`过程宏允许我们设置system的运行时机，目前支持两种运行时机：
| mod中声明的运行时机 | 在游戏中实际的运行时机 |
| -- | -- |
| Startup | PostStartup |
| Update | PostUpdate |

mod开发者可以通过`schedule`设置运行时机，如果没有设置，或值不合法，那么都将使用默认的Update运行时机

---

system_def宏定义了mod中所有的系统，一个mod有且只有一个

## 在mod中查询组件
### 游戏本体中定义一个组件并创造一个实体
```rs
#[mod_component(id = "square")] // 为组件标记并设置唯一id
#[derive(Component, Debug)]
pub struct Square(pub Vec2);
#[mod_component(id = "rect")]
#[derive(Component, Debug)]
pub struct Rect(pub IVec2);

fn spawn_example_component(mut commands: Commands) {
    commands.spawn((Square(Vec2 { x: 0.0, y: 1.0 }), Rect(IVec2 { x: 3, y: 4 })));
    commands.spawn((
        Square(Vec2 { x: 2.0, y: 3.6 }),
        Rect(IVec2 { x: 32, y: 48 }),
    ));
}

fn main() {
    App::new()
       // ...
        .add_systems(Startup, spawn_example_component)
		// ...
        .run();
}
```

### 修改sdk
我们需要在开源的sdk中编写一个与游戏本体中定义的可以让mod访问的组件签名完全相同的结构体。

在此之前，我们需要在Cargo.toml中添加必要的依赖：
```toml
# ...
[dependencies]
bevy_math = { version = "0.16", features = ['serialize'] }
# ...
```

*note: 此处我们不依赖bevy，防止编译wasm32-wasip1出现意外错误*

然后，我们在lib.rs中添加结构体
```
#[component(id = "square")]
pub struct Square(pub bevy_math::Vec2);
#[component(id = "rect")]
pub struct Rect(pub bevy_math::IVec2);
```

*note: 此处的结构体签名应与游戏本体中完全一致，组件的id也应与游戏本体完全一致。并使用bevy_modsdk提供的component宏进行标记*

### 在mod中进行查询
最后，我们在mod中查询组件。我们在此直接修改`example_update_system`：
```rs
#[system(schedule = Update)]
pub fn example_update_system() {
    log_info!("Update system running from mod");

    for (square, rect) in query!(Square, Rect) {
        log_info!("From Mod: Found square: {:?} and rect: {:?}", square.0, rect.0);
    }
}
```

最后，重新编译mod并运行游戏本体，查看运行结果。

## 在mod中创建实体
我们可以轻松的在mod中创建实体，我们现在想要创建`(Square, Rect)`的实体，我们只需要修改mod的代码即可。我们将添加一个新的Startup系统来创建实体。
```rs
#[system(schedule = Startup)]
pub fn example_startup_system() {
    log_info!("Startup system running from mod");;
    
    spawn!(Square(Vec2 { x: 100.0, y: 120.6 }), Rect(IVec2 { x: 60, y: 66 }));
    spawn!(Square(Vec2 { x: 100.0, y: 120.3 }), Rect(IVec2 { x: 60, y: 88 }));
}

system_def!(example_startup_system, example_update_system); // 修改system_def，添加这个系统
```

然后，我们重新编译mod并运行游戏本体即可。

## 在mod中获取游戏Resource
获取Resource的方法与查询组件的方法类似

### 在游戏本体中定义并添加资源
```rs
#[mod_resource(id = "player")] // 标记并设置资源唯一id
#[derive(Resource, Debug)]
pub struct Player(pub Vec2);

fn main() {
    App::new()
        // ...
		.insert_resource(Player(Vec2 { x: 10.0, y: 20.0 }))
        .run();
}
```

### 修改游戏sdk
```rs
#[resource(id = "player")] // 确保id与签名都与游戏本体一致
pub struct Player(pub bevy_math::Vec2);
```

### 在mod中查询资源
我们直接修改`example_update_system`
```rs
#[system(schedule = Update)]
pub fn example_update_system() {
    log_info!("Update system running from mod");

    for (square, rect) in query!(Square, Rect) {
        log_info!("From Mod: Found square: {:?} and rect: {:?}", square.0, rect.0);
    }
    
    // 添加资源查询功能
    if let Some(player) = res!(Player) {
        log_info!("From Mod: Found player: {:?}", player.0);
    } else {
        log_warn!("From Mod: Player resource not found");
    }
}
```

最后，我们直接重新编译mod并运行游戏本体查看结果

## 在mod中添加资产
我们可以在mod中添加游戏所需的资产，可能是图片、音频等。为了演示，在这里，我们使用简单的文本文件作为示例

### 在mod的src目录下创建一个文本文件
创建一个文本文件`example_asset.txt`，写入
```
This is an example asset file for the Bevy WASM mod example.
```

### 在mod中添加资产
我们直接修改`example_startup_system`
```
#[system(schedule = Startup)]
pub fn example_startup_system() {
    log_info!("Startup system running from mod");
    
    // Define an asset and get its ID
    let asset_id = asset_def!(type=text, src="example_asset.txt");
    log_info!("Defined asset with ID: {}", asset_id);
    
    spawn!(Square(Vec2 { x: 100.0, y: 120.6 }), Rect(IVec2 { x: 60, y: 66 }));
    spawn!(Square(Vec2 { x: 100.0, y: 120.3 }), Rect(IVec2 { x: 60, y: 88 }));
}
```

*note: 在asset_def宏中会使用include_bytes宏直接将资产二进制打包*

### 在游戏本体中添加并设置资产添加函数
首先，我们定义一个资产接收函数。注意，该函数的参数签名和返回值签名是固定的。
```
fn handle_new_asset(_world: &mut World, asset_info: AssetInfo) -> String {
    info!("New asset from mod:");
    info!("  Mod name: {}", asset_info.mod_name);
    info!("  Asset type: {}", asset_info.asset_type);
    info!(
        "  Asset data: {}",
        String::from_utf8_lossy(&asset_info.asset_data)
    );

    // 此处应当为mod返回资产id。
    // 资产id可以看作是所有mod添加的资产的唯一id，由游戏开发者处理。如果希望mod能够获取资产，那么资产id是必要的。在此处我们留空
    String::new()
}
```

然后，我们修改我们`WasmModPlugin`的设置
```rs
fn main() {
    App::new()
        // ...
        .add_plugins(
            WasmModPlugin::default()
                .add_mod_path(
                    "path/to/your/mod.wasm",
                )
                .set_new_asset_fn(handle_new_asset),
        )
        .run();
}
```

最后，我们重新编译mod，运行程序并查看结果。

## 示例项目
以上演示均可以在[hello_world](../../examples/hello_world/README.md)示例中找到